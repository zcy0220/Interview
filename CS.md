# C#基础

## Lamada表达式
* 简化了匿名委托的使用，代码更加简洁

## 委托和事件的区别
* 委托就是一个类，也可以实例化，通过委托的构造函数来把方法赋值给委托实例
* 事件可以看作是一个委托类型的变量
* 委托是类，所以可以在任何地方创建，而事件是变量，只能在类里面声明，不需要实例化
* 事件2个方法（+=、-=），调用一次+=方法，其实是把该方法封装成对应类型的委托对象，然后把这对象的引用赋值给事件变量
* 委托一对一，事件一对多

## 闭包
* 闭包是指有权访问另一个函数作用域中的变量的函数
* 闭包本身指的是一种函数，而创建这种特殊函数的一种常见方式是在一个函数中创建另一个函数

## 什么是弱引用？弱引用的使用和作用？弱引用和强引用的区别
* 强引用：强引用最终导致的结果就是被引用的对象的被引用次数+1
* 弱引用：不会对被引用对象的被引用次数有任何影响
* 弱引用的作用：防止内存泄露
~~~ C#
Object obj = new Object();
WeakReference wref = new WeakReference( obj );
obj = null;
Object obj2 = wref.Target;
if( obj2 != null )
{
	// 做你想做的事吧。
}
else
{
	// 对象已经被回收，如果要用必须新建一个。
}
~~~

## 死锁问题
* 由于多个进程共享资源而引起的不能向前推进的僵死状态（两个或多个进程因竞争资源而无休止的等待着其他进程释放已占有的资源）
* 互斥条件：一个资源在一段时间内只能由一个进程占用
* 保持等待条件：各个进程保持自己的资源，当又提出了新的资源请求，而该资源已被其他进程占用，此时请求进程阻塞，但又对自己已获得的其他资源保持不放
* 不剥夺条件：进程已获得的资源，在未使用完之前，不能被剥夺，只能在使用完时由自己释放
* 环路等待条件：P1等待P2，P2等待P3，......，Pn等待P1
* 死锁的预防，打破4大条件
* 打破互斥条件：各个进程可以同时使用资源，需要注意的是互斥条件是不能摒弃的，因为一旦摒弃互斥条件，有可能使访问临界资源的进程出现执行结果的错误
* 打破保持等待条件：当进程因请求不到资源处于请求阻塞状态时，主要将自己拥有的资源分配给其他资源
* 打破不可剥夺条件：当进行缺少资源时，可从其他进程剥夺相应的资源使自己运行
* 打破环路等待条件：实现资源有序分配策略

## 对象池
* 通过循环使用对象，减少资源在初始化和释放时的消耗
* 对象池大小的设定问题，太小则起不到作用，太大则占用内存

## C# GC
* Garbage Collector 以应用程序的root为基础，遍历应用程序在堆上动态分配的所有对象，通过识别它们是否被引用来确定哪些对象是已经死亡的、哪些仍需要被使用。已经不再被应用程序的root或者别的对象所引用的对象就是已经死亡的对象，即所谓的垃圾，需要被回收，这就是GC工作的原理
* Mark Sweep算法

## GC 优化
* 对象池
* 尽量不要使用foreach，而是使用for
* 参数数组：装箱拆箱问题，还会产生GC
* 重载和泛型
~~~ C#
public void Test(params int[] values);
public void Test(int a, int b);
obj.Test(1,2); // 如果调用是两个参数的Min方法，不会产生GC
obj.Test(3);   // 相当于Test(new int[]{3})，创建个数组
// 同理 public void Test(params object[] values)
~~~
* 字符串合并，转换等都会产生GC，用StringBuilder
* xLua：
	- Vector3等这种 struct 结构体 要传给lua，会new一块userdata，拷贝一份数据出来，产生GC，优化方法可以是参数改成传三个float
	- 自定义结构体改成class，就变成引用，不产生GC
	- 枚举类型传的时候也会产生GC，可以用整形来传，再做转换

## 非托管资源回收
* 托管资源：int、string、float等大多数应用程序创建的对象，系统管理回收
* 非托管资源：Stream、数据库的连接等，需要手动去释放。最常见的一类非托管资源就是包装操作系统资源的对象，如文件、网络连接等
* 释放非托管资源的2种方法：
	- 析构函数
	- 实现System.IDisposable接口
* 在删除C++对象时，其析构函数会立即执行。但C#对象的析构函数，是要等垃圾收集器来释放该对象才调用的，所以也就无法确定其何时执行
* IDisposable接口定义了一个模式，为释放未托管的资源提供了确定的机制，并避免产生析构函数固有的与垃圾收集器相关的问题，其提供了一个方法Dispose()
* Finalize：用于释放非托管资源，被GC调用
* Dispose：需要同时释放托管和非托管的资源，该函数是被其它代码显示调用并要求释放资源的
* Finalize和Dispose重复调用没有问题

## TCP和UDP特征以及区别
* 这2个协议同属于传输层
* UPD
	- 不可靠通信
	- UDP是无连接的。减少了开销和发送延迟
	- UDP使用尽最大努力交付，不保证可靠的交付
	- UDP没有阻塞控制
	- UDP支持1对1、1对多、多对1的交互通信
	- UDP首部开销小
	- UDP是面向报文的
* TCP
	- 提供面向连接服务，相当于全双工可靠通信
	- TCP协议使用前必须建立TCP连接，传输结束必须释放已经建立的连接
	- 每个连接只能有2个端点，点对点连接
	- TCP提供可靠交付服务，无差错，不丢失，不重复，按序到达
	- 全双工通信，2端均接收和发送缓存
	- 面向字节流，TCP把应用交付下来的数据仅仅看作一连串无结构的字节流
	- 字节流大于缓存区就要进行拆包和粘包解析，增加消息长度处理
* Upd如何实现可靠传输（这里只讲下KCP的原理）
	- 确认机制、重传机制、滑动窗口
	- RTO（重传超时时间）：TCP的RTO是以2倍的方式来计算的。当丢包的次数多的时候，重传超时时间RTO就非常非常的大了，重传就非常的慢，效率低，性能差。而KCP的RTO可以以1.5倍的速度增长，相对于TCP来说，有更短的重传超时时间
	- 选择性重传 vs 全部重传：TCP丢包时会全部重传从丢的那个包开始以后的数据，KCP是选择性重传，只重传真正丢失的数据包
	- 快速重传机制—无延迟ACK回复模式，假如开启KCP的快速重传机制，并且设置了当重复的ACK个数大于resend时候，直接进行重传。 当发送端发送了1,2,3,4,5五个包，然后收到远端的ACK：1,3,4,5。当收到ACK3时，KCP知道2被跳过1次，当收到ACK4的时候，KCP知道2被跳过2次，当次数大于等于设置的resend的值的时候，不用等到超时，可直接重传2号包。这就是KCP的快速重传机制

## 进程通讯方式
* 管道、消息队列、信号量、共享存储、Socket等
* 管道
	- 半双工（即数据只能在一个方向上流动），具有固定的读端和写端
	- 只能用于类似父子进程或兄弟进程之间
	- 它可以看成是一种特殊的文件，对于它的读写也可以使用普通的read、write等。但它不是普通的文件，并不属于其他任何文件系统，并且只存在于内存中
* FIFO
	- 可以在无关的进程之间交换数据
* 消息队列
	- 面向记录的
	- 独立于发送与接受进程
	- 可以实现消息的随机查询
* 信号量
	- 信号量用于进程间同步，若要在进程间传递数据需要结合共享内存
* 共享内存
	- 共享内存是最快的一种IPC，因为进程是直接对内存进行存取的
	- 因为多个进程可以同时操作，所以需要进行同步
	- 信号量+共享内存通常结合在一起使用，信号量用来同步对共享内存的访问

## 补码求解
* 计算机中是以补码形式存储值的
	- 加减运算的正确性
	- 0和-0
	- 正数：00000000 - 01111111
	- 负数：10000000 - 11111111 (10000000 = -128)
	- -128 - 127
* 正数：原码本身
* 负数：符号位为1，其余位数取反加1

## 子掩码计算
* 子网掩码通常是用于划分网络使用

## 反射
* 反射提供了封装程序集、模块和类型的对象（Type类型）。可以使用反射动态创建类型的实例，将类型绑定到现有对象，或从现有对象获取类型并调用其方法或访问其字段和属性
* 反射速度慢的原因是需要做更多的工作：校验参数，检查权限等等

## 值类型和引用类型的区别
* 值类型存储速度快，引用类型存储速度慢
* 值类型直接存放实际的数据，引用类型存放的数据地址
* 值类型直接把变量的值存在堆栈中，引用类型是把实际数据的地址存放在堆栈上，而实际的数据存放在堆中
